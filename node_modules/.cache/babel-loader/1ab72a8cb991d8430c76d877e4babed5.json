{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValidationContext = exports.SimpleSchema = exports.schemaDefinitionOptions = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _clone = require('clone');\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _lodash = require('lodash.every');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _extend2 = require('extend');\n\nvar _extend3 = _interopRequireDefault(_extend2);\n\nvar _lodash3 = require('lodash.includes');\n\nvar _lodash4 = _interopRequireDefault(_lodash3);\n\nvar _lodash5 = require('lodash.isempty');\n\nvar _lodash6 = _interopRequireDefault(_lodash5);\n\nvar _messageBox = require('message-box');\n\nvar _messageBox2 = _interopRequireDefault(_messageBox);\n\nvar _mongoObject = require('mongo-object');\n\nvar _mongoObject2 = _interopRequireDefault(_mongoObject);\n\nvar _lodash7 = require('lodash.omit');\n\nvar _lodash8 = _interopRequireDefault(_lodash7);\n\nvar _lodash9 = require('lodash.pick');\n\nvar _lodash10 = _interopRequireDefault(_lodash9);\n\nvar _lodash11 = require('lodash.uniq');\n\nvar _lodash12 = _interopRequireDefault(_lodash11);\n\nvar _humanize = require('./humanize.js');\n\nvar _humanize2 = _interopRequireDefault(_humanize);\n\nvar _ValidationContext = require('./ValidationContext');\n\nvar _ValidationContext2 = _interopRequireDefault(_ValidationContext);\n\nvar _SimpleSchemaGroup = require('./SimpleSchemaGroup');\n\nvar _SimpleSchemaGroup2 = _interopRequireDefault(_SimpleSchemaGroup);\n\nvar _regExp = require('./regExp');\n\nvar _regExp2 = _interopRequireDefault(_regExp);\n\nvar _clean2 = require('./clean');\n\nvar _clean3 = _interopRequireDefault(_clean2);\n\nvar _expandShorthand = require('./expandShorthand');\n\nvar _expandShorthand2 = _interopRequireDefault(_expandShorthand);\n\nvar _utility = require('./utility');\n\nvar _defaultMessages = require('./defaultMessages');\n\nvar _defaultMessages2 = _interopRequireDefault(_defaultMessages);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Exported for tests\n\n\nvar schemaDefinitionOptions = exports.schemaDefinitionOptions = ['type', 'label', 'optional', 'required', 'autoValue', 'defaultValue'];\nvar oneOfProps = ['type', 'min', 'max', 'minCount', 'maxCount', 'allowedValues', 'exclusiveMin', 'exclusiveMax', 'regEx', 'custom', 'blackbox', 'trim'];\nvar propsThatCanBeFunction = ['label', 'optional', 'min', 'max', 'minCount', 'maxCount', 'allowedValues', 'exclusiveMin', 'exclusiveMax', 'regEx'];\n\nvar SimpleSchema = function () {\n  function SimpleSchema() {\n    var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        check = _ref.check,\n        cleanOptions = _ref.clean,\n        defaultLabel = _ref.defaultLabel,\n        _ref$humanizeAutoLabe = _ref.humanizeAutoLabels,\n        humanizeAutoLabels = _ref$humanizeAutoLabe === undefined ? true : _ref$humanizeAutoLabe,\n        _ref$requiredByDefaul = _ref.requiredByDefault,\n        requiredByDefault = _ref$requiredByDefaul === undefined ? true : _ref$requiredByDefaul,\n        tracker = _ref.tracker;\n\n    _classCallCheck(this, SimpleSchema);\n\n    this.pick = getPickOrOmit('pick');\n    this.omit = getPickOrOmit('omit'); // Stash the options object\n\n    this._constructorOptions = {\n      check: check,\n      defaultLabel: defaultLabel,\n      humanizeAutoLabels: humanizeAutoLabels,\n      requiredByDefault: requiredByDefault,\n      tracker: tracker\n    }; // Custom validators for this instance\n\n    this._validators = [];\n    this._docValidators = []; // Named validation contexts\n\n    this._validationContexts = {}; // Schema-level defaults for cleaning\n\n    this._cleanOptions = _extends({\n      filter: true,\n      autoConvert: true,\n      removeEmptyStrings: true,\n      trimStrings: true,\n      getAutoValues: true,\n      removeNullsFromArrays: false,\n      extendAutoValueContext: {}\n    }, cleanOptions); // Clone, expanding shorthand, and store the schema object in this._schema\n\n    this._schema = {};\n    this._depsLabels = {};\n    this.extend(schema); // Define default validation error messages\n\n    this.messageBox = new _messageBox2.default((0, _clone2.default)(_defaultMessages2.default));\n    this.version = SimpleSchema.version;\n  }\n\n  _createClass(SimpleSchema, [{\n    key: 'forEachAncestorSimpleSchema',\n    value: function forEachAncestorSimpleSchema(key, func) {\n      var _this = this;\n\n      var genericKey = _mongoObject2.default.makeKeyGeneric(key);\n\n      (0, _utility.forEachKeyAncestor)(genericKey, function (ancestor) {\n        var def = _this._schema[ancestor];\n        if (!def) return;\n        def.type.definitions.forEach(function (typeDef) {\n          if (SimpleSchema.isSimpleSchema(typeDef.type)) {\n            func(typeDef.type, ancestor, genericKey.slice(ancestor.length + 1));\n          }\n        });\n      });\n    }\n    /**\n     * Returns whether the obj is a SimpleSchema object.\n     * @param {Object} [obj] An object to test\n     * @returns {Boolean} True if the given object appears to be a SimpleSchema instance\n     */\n\n  }, {\n    key: 'reactiveLabelDependency',\n\n    /**\n     * For Meteor apps, add a reactive dependency on the label\n     * for a key.\n     */\n    value: function reactiveLabelDependency(key) {\n      var tracker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._constructorOptions.tracker;\n      if (!key || !tracker) return;\n\n      var genericKey = _mongoObject2.default.makeKeyGeneric(key); // If in this schema\n\n\n      if (this._schema[genericKey]) {\n        if (!this._depsLabels[genericKey]) {\n          this._depsLabels[genericKey] = new tracker.Dependency();\n        }\n\n        this._depsLabels[genericKey].depend();\n\n        return;\n      } // If in subschema\n\n\n      this.forEachAncestorSimpleSchema(key, function (simpleSchema, ancestor, subSchemaKey) {\n        // Pass tracker down so that we get reactivity even if the subschema\n        // didn't have tracker option set\n        simpleSchema.reactiveLabelDependency(subSchemaKey, tracker);\n      });\n    }\n    /**\n     * @param {String} [key] One specific or generic key for which to get the schema.\n     * @returns {Object} The entire schema object or just the definition for one key.\n     *\n     * Note that this returns the raw, unevaluated definition object. Use `getDefinition`\n     * if you want the evaluated definition, where any properties that are functions\n     * have been run to produce a result.\n     */\n\n  }, {\n    key: 'schema',\n    value: function schema(key) {\n      if (!key) return this._schema;\n\n      var genericKey = _mongoObject2.default.makeKeyGeneric(key);\n\n      var keySchema = this._schema[genericKey]; // If not defined in this schema, see if it's defined in a subschema\n\n      if (!keySchema) {\n        var found = false;\n        this.forEachAncestorSimpleSchema(key, function (simpleSchema, ancestor, subSchemaKey) {\n          if (!found) keySchema = simpleSchema.schema(subSchemaKey);\n          if (keySchema) found = true;\n        });\n      }\n\n      return keySchema;\n    }\n    /**\n     * @returns {Object} The entire schema object with subschemas merged. This is the\n     * equivalent of what schema() returned in SimpleSchema < 2.0\n     *\n     * Note that this returns the raw, unevaluated definition object. Use `getDefinition`\n     * if you want the evaluated definition, where any properties that are functions\n     * have been run to produce a result.\n     */\n\n  }, {\n    key: 'mergedSchema',\n    value: function mergedSchema() {\n      var _this2 = this;\n\n      var mergedSchema = {};\n\n      this._schemaKeys.forEach(function (key) {\n        var keySchema = _this2._schema[key];\n        mergedSchema[key] = keySchema;\n        keySchema.type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          var childSchema = typeDef.type.mergedSchema();\n          Object.keys(childSchema).forEach(function (subKey) {\n            mergedSchema[key + '.' + subKey] = childSchema[subKey];\n          });\n        });\n      });\n\n      return mergedSchema;\n    }\n    /**\n     * Returns the evaluated definition for one key in the schema\n     *\n     * @param {String} key Generic or specific schema key\n     * @param {Array(String)} [propList] Array of schema properties you need; performance optimization\n     * @param {Object} [functionContext] The context to use when evaluating schema options that are functions\n     * @returns {Object} The schema definition for the requested key\n     */\n\n  }, {\n    key: 'getDefinition',\n    value: function getDefinition(key, propList) {\n      var _this3 = this;\n\n      var functionContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var defs = this.schema(key);\n      if (!defs) return;\n\n      var getPropIterator = function getPropIterator(obj, newObj) {\n        return function (prop) {\n          if (Array.isArray(propList) && !(0, _lodash4.default)(propList, prop)) return;\n          var val = obj[prop]; // For any options that support specifying a function, evaluate the functions\n\n          if (propsThatCanBeFunction.indexOf(prop) > -1 && typeof val === 'function') {\n            newObj[prop] = val.call(_extends({\n              key: key\n            }, functionContext)); // Inflect label if undefined\n\n            if (prop === 'label' && typeof newObj[prop] !== 'string') newObj[prop] = inflectedLabel(key, _this3._constructorOptions.humanizeAutoLabels);\n          } else {\n            newObj[prop] = val;\n          }\n        };\n      };\n\n      var result = {};\n      Object.keys(defs).forEach(getPropIterator(defs, result)); // Resolve all the types and convert to a normal array to make it easier\n      // to use.\n\n      if (defs.type) {\n        result.type = defs.type.definitions.map(function (typeDef) {\n          var newTypeDef = {};\n          Object.keys(typeDef).forEach(getPropIterator(typeDef, newTypeDef));\n          return newTypeDef;\n        });\n      }\n\n      return result;\n    }\n    /**\n     * Returns a string identifying the best guess data type for a key. For keys\n     * that allow multiple types, the first type is used. This can be useful for\n     * building forms.\n     *\n     * @param {String} key Generic or specific schema key\n     * @returns {String} A type string. One of:\n     *  string, number, boolean, date, object, stringArray, numberArray, booleanArray,\n     *  dateArray, objectArray\n     */\n\n  }, {\n    key: 'getQuickTypeForKey',\n    value: function getQuickTypeForKey(key) {\n      var type = void 0;\n      var fieldSchema = this.schema(key);\n      if (!fieldSchema) return;\n      var fieldType = fieldSchema.type.singleType;\n\n      if (fieldType === String) {\n        type = 'string';\n      } else if (fieldType === Number || fieldType === SimpleSchema.Integer) {\n        type = 'number';\n      } else if (fieldType === Boolean) {\n        type = 'boolean';\n      } else if (fieldType === Date) {\n        type = 'date';\n      } else if (fieldType === Array) {\n        var arrayItemFieldSchema = this.schema(key + '.$');\n        if (!arrayItemFieldSchema) return;\n        var arrayItemFieldType = arrayItemFieldSchema.type.singleType;\n\n        if (arrayItemFieldType === String) {\n          type = 'stringArray';\n        } else if (arrayItemFieldType === Number || arrayItemFieldType === SimpleSchema.Integer) {\n          type = 'numberArray';\n        } else if (arrayItemFieldType === Boolean) {\n          type = 'booleanArray';\n        } else if (arrayItemFieldType === Date) {\n          type = 'dateArray';\n        } else if (arrayItemFieldType === Object || SimpleSchema.isSimpleSchema(arrayItemFieldType)) {\n          type = 'objectArray';\n        }\n      } else if (fieldType === Object) {\n        type = 'object';\n      }\n\n      return type;\n    }\n    /**\n     * Given a key that is an Object, returns a new SimpleSchema instance scoped to that object.\n     *\n     * @param {String} key Generic or specific schema key\n     */\n\n  }, {\n    key: 'getObjectSchema',\n    value: function getObjectSchema(key) {\n      var newSchemaDef = {};\n\n      var genericKey = _mongoObject2.default.makeKeyGeneric(key);\n\n      var searchString = genericKey + '.';\n      var mergedSchema = this.mergedSchema();\n      Object.keys(mergedSchema).forEach(function (k) {\n        if (k.indexOf(searchString) === 0) {\n          newSchemaDef[k.slice(searchString.length)] = mergedSchema[k];\n        }\n      });\n      return this._copyWithSchema(newSchemaDef);\n    } // Returns an array of all the autovalue functions, including those in subschemas all the\n    // way down the schema tree\n\n  }, {\n    key: 'autoValueFunctions',\n    value: function autoValueFunctions() {\n      var _this4 = this;\n\n      var result = [].concat(this._autoValues);\n\n      this._schemaKeys.forEach(function (key) {\n        _this4._schema[key].type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          result = result.concat(typeDef.type.autoValueFunctions().map(function (_ref2) {\n            var func = _ref2.func,\n                fieldName = _ref2.fieldName,\n                closestSubschemaFieldName = _ref2.closestSubschemaFieldName;\n            return {\n              func: func,\n              fieldName: key + '.' + fieldName,\n              closestSubschemaFieldName: closestSubschemaFieldName.length ? key + '.' + closestSubschemaFieldName : key\n            };\n          }));\n        });\n      });\n\n      return result;\n    } // Returns an array of all the blackbox keys, including those in subschemas\n\n  }, {\n    key: 'blackboxKeys',\n    value: function blackboxKeys() {\n      var _this5 = this;\n\n      var blackboxKeys = this._blackboxKeys;\n\n      this._schemaKeys.forEach(function (key) {\n        _this5._schema[key].type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n\n          typeDef.type._blackboxKeys.forEach(function (blackboxKey) {\n            blackboxKeys.push(key + '.' + blackboxKey);\n          });\n        });\n      });\n\n      return (0, _lodash12.default)(blackboxKeys);\n    } // Check if the key is a nested dot-syntax key inside of a blackbox object\n\n  }, {\n    key: 'keyIsInBlackBox',\n    value: function keyIsInBlackBox(key) {\n      var _this6 = this;\n\n      var isInBlackBox = false;\n      (0, _utility.forEachKeyAncestor)(_mongoObject2.default.makeKeyGeneric(key), function (ancestor, remainder) {\n        if (_this6._blackboxKeys.indexOf(ancestor) > -1) {\n          isInBlackBox = true;\n        } else {\n          var testKeySchema = _this6.schema(ancestor);\n\n          if (testKeySchema) {\n            testKeySchema.type.definitions.forEach(function (typeDef) {\n              if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n              if (typeDef.type.keyIsInBlackBox(remainder)) isInBlackBox = true;\n            });\n          }\n        }\n      });\n      return isInBlackBox;\n    } // Returns true if key is explicitly allowed by the schema or implied\n    // by other explicitly allowed keys.\n    // The key string should have $ in place of any numeric array positions.\n\n  }, {\n    key: 'allowsKey',\n    value: function allowsKey(key) {\n      var _this7 = this; // Loop through all keys in the schema\n\n\n      return this._schemaKeys.some(function (loopKey) {\n        // If the schema key is the test key, it's allowed.\n        if (loopKey === key) return true;\n\n        var fieldSchema = _this7.schema(loopKey);\n\n        var compare1 = key.slice(0, loopKey.length + 2);\n        var compare2 = compare1.slice(0, -1); // Blackbox and subschema checks are needed only if key starts with\n        // loopKey + a dot\n\n        if (compare2 !== loopKey + '.') return false; // Black box handling\n\n        if (_this7._blackboxKeys.indexOf(loopKey) > -1) {\n          // If the test key is the black box key + \".$\", then the test\n          // key is NOT allowed because black box keys are by definition\n          // only for objects, and not for arrays.\n          return compare1 !== loopKey + '.$';\n        } // Subschemas\n\n\n        var allowed = false;\n        var subKey = key.slice(loopKey.length + 1);\n        fieldSchema.type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          if (typeDef.type.allowsKey(subKey)) allowed = true;\n        });\n        return allowed;\n      });\n    }\n    /**\n     * Returns all the child keys for the object identified by the generic prefix,\n     * or all the top level keys if no prefix is supplied.\n     *\n     * @param {String} [keyPrefix] The Object-type generic key for which to get child keys. Omit for\n     *   top-level Object-type keys\n     * @returns {[[Type]]} [[Description]]\n     */\n\n  }, {\n    key: 'objectKeys',\n    value: function objectKeys(keyPrefix) {\n      if (!keyPrefix) return this._firstLevelSchemaKeys;\n      return this._objectKeys[keyPrefix + '.'] || [];\n    }\n    /**\n     * Copies this schema into a new instance with the same validators, messages,\n     * and options, but with different keys as defined in `schema` argument\n     *\n     * @param {Object} schema\n     * @returns The new SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: '_copyWithSchema',\n    value: function _copyWithSchema(schema) {\n      var cl = new SimpleSchema(schema, (0, _clone2.default)(this._constructorOptions, false, 1));\n      cl._cleanOptions = this._cleanOptions;\n      cl.messageBox = this.messageBox.clone();\n      return cl;\n    }\n    /**\n     * Clones this schema into a new instance with the same schema keys, validators,\n     * and options.\n     *\n     * @returns The new SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: 'clone',\n    value: function clone() {\n      return this._copyWithSchema(this._schema);\n    }\n    /**\n     * Extends (mutates) this schema with another schema, key by key.\n     *\n     * @param {SimpleSchema|Object} schema\n     * @returns The SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: 'extend',\n    value: function extend() {\n      var _this8 = this;\n\n      var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (Array.isArray(schema)) throw new Error('You may not pass an array of schemas to the SimpleSchema constructor or to extend()');\n      var schemaObj = void 0;\n\n      if (SimpleSchema.isSimpleSchema(schema)) {\n        schemaObj = schema._schema;\n        this._validators = this._validators.concat(schema._validators);\n        this._docValidators = this._docValidators.concat(schema._docValidators);\n        this._cleanOptions = (0, _extend3.default)(false, this._cleanOptions, schema._cleanOptions);\n        this._constructorOptions = (0, _extend3.default)(false, this._constructorOptions, schema._constructorOptions);\n      } else {\n        schemaObj = (0, _expandShorthand2.default)(schema);\n      } // Update all of the information cached on the instance\n\n\n      Object.keys(schemaObj).forEach(function (fieldName) {\n        var definition = standardizeDefinition(schemaObj[fieldName]); // Merge/extend with any existing definition\n\n        if (_this8._schema[fieldName]) {\n          if (!_this8._schema.hasOwnProperty(fieldName)) {\n            // fieldName is actually a method from Object itself!\n            throw new Error(fieldName + ' key is actually the name of a method on Object, please rename it');\n          }\n\n          _this8._schema[fieldName] = _extends({}, _this8._schema[fieldName], (0, _lodash8.default)(definition, 'type'));\n          if (definition.type) _this8._schema[fieldName].type.extend(definition.type);\n        } else {\n          _this8._schema[fieldName] = definition;\n        }\n\n        checkAndScrubDefinition(fieldName, _this8._schema[fieldName], _this8._constructorOptions, schemaObj);\n      });\n      checkSchemaOverlap(this._schema); // Set/Reset all of these\n\n      this._schemaKeys = Object.keys(this._schema);\n      this._autoValues = [];\n      this._blackboxKeys = [];\n      this._firstLevelSchemaKeys = [];\n      this._objectKeys = {}; // Update all of the information cached on the instance\n\n      this._schemaKeys.forEach(function (fieldName) {\n        // Make sure parent has a definition in the schema. No implied objects!\n        if (fieldName.indexOf('.') > -1) {\n          var parentFieldName = fieldName.slice(0, fieldName.lastIndexOf('.'));\n          if (!_this8._schema.hasOwnProperty(parentFieldName)) throw new Error('\"' + fieldName + '\" is in the schema but \"' + parentFieldName + '\" is not');\n        }\n\n        var definition = _this8._schema[fieldName]; // Keep list of all top level keys\n\n        if (fieldName.indexOf('.') === -1) _this8._firstLevelSchemaKeys.push(fieldName); // Keep list of all blackbox keys for passing to MongoObject constructor\n        // XXX For now if any oneOf type is blackbox, then the whole field is.\n\n        (0, _lodash2.default)(definition.type.definitions, function (oneOfDef) {\n          if (oneOfDef.blackbox === true) {\n            _this8._blackboxKeys.push(fieldName);\n\n            return false; // exit loop\n          }\n\n          return true;\n        }); // Keep list of autoValue functions\n\n        if (typeof definition.autoValue === 'function') {\n          _this8._autoValues.push({\n            closestSubschemaFieldName: '',\n            fieldName: fieldName,\n            func: definition.autoValue\n          });\n        }\n      }); // Store child keys keyed by parent. This needs to be done recursively to handle\n      // subschemas.\n\n\n      var setObjectKeys = function setObjectKeys(curSchema, schemaParentKey) {\n        Object.keys(curSchema).forEach(function (fieldName) {\n          var definition = curSchema[fieldName];\n          fieldName = schemaParentKey ? schemaParentKey + '.' + fieldName : fieldName;\n\n          if (fieldName.indexOf('.') > -1 && fieldName.slice(-2) !== '.$') {\n            var parentKey = fieldName.slice(0, fieldName.lastIndexOf('.'));\n            var parentKeyWithDot = parentKey + '.';\n            _this8._objectKeys[parentKeyWithDot] = _this8._objectKeys[parentKeyWithDot] || [];\n\n            _this8._objectKeys[parentKeyWithDot].push(fieldName.slice(fieldName.lastIndexOf('.') + 1));\n          } // If the current field is a nested SimpleSchema,\n          // iterate over the child fields and cache their properties as well\n\n\n          definition.type.definitions.forEach(function (_ref3) {\n            var type = _ref3.type;\n\n            if (SimpleSchema.isSimpleSchema(type)) {\n              setObjectKeys(type._schema, fieldName);\n            }\n          });\n        });\n      };\n\n      setObjectKeys(this._schema);\n      return this;\n    }\n  }, {\n    key: 'getAllowedValuesForKey',\n    value: function getAllowedValuesForKey(key) {\n      // For array fields, `allowedValues` is on the array item definition\n      if (this.allowsKey(key + '.$')) {\n        key = key + '.$';\n      }\n\n      var allowedValues = this.get(key, 'allowedValues');\n      return (0, _lodash6.default)(allowedValues) ? null : [].concat(_toConsumableArray(allowedValues));\n    }\n  }, {\n    key: 'newContext',\n    value: function newContext() {\n      return new _ValidationContext2.default(this);\n    }\n  }, {\n    key: 'namedContext',\n    value: function namedContext(name) {\n      if (typeof name !== 'string') name = 'default';\n\n      if (!this._validationContexts[name]) {\n        this._validationContexts[name] = new _ValidationContext2.default(this);\n      }\n\n      return this._validationContexts[name];\n    }\n  }, {\n    key: 'addValidator',\n    value: function addValidator(func) {\n      this._validators.push(func);\n    }\n  }, {\n    key: 'addDocValidator',\n    value: function addDocValidator(func) {\n      this._docValidators.push(func);\n    }\n    /**\n     * @param obj {Object|Object[]} Object or array of objects to validate.\n     * @param [options] {Object} Same options object that ValidationContext#validate takes\n     *\n     * Throws an Error with name `ClientError` and `details` property containing the errors.\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(obj) {\n      var _this9 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // For Meteor apps, `check` option can be passed to silence audit-argument-checks\n\n      var check = options.check || this._constructorOptions.check;\n\n      if (typeof check === 'function') {\n        // Call check but ignore the error\n        try {\n          check(obj);\n        } catch (e) {\n          /* ignore error */\n        }\n      } // obj can be an array, in which case we validate each object in it and\n      // throw as soon as one has an error\n\n\n      var objects = Array.isArray(obj) ? obj : [obj];\n      objects.forEach(function (oneObj) {\n        var validationContext = _this9.newContext();\n\n        var isValid = validationContext.validate(oneObj, options);\n        if (isValid) return;\n        var errors = validationContext.validationErrors(); // In order for the message at the top of the stack trace to be useful,\n        // we set it to the first validation error message.\n\n        var message = _this9.messageForError(errors[0]);\n\n        var error = new Error(message);\n        error.name = error.errorType = 'ClientError';\n        error.error = 'validation-error'; // Add meaningful error messages for each validation error.\n        // Useful for display messages when using 'mdg:validated-method'.\n\n        error.details = errors.map(function (errorDetail) {\n          return _extends({}, errorDetail, {\n            message: _this9.messageForError(errorDetail)\n          });\n        }); // The primary use for the validationErrorTransform is to convert the\n        // vanilla Error into a Meteor.Error until DDP is able to pass\n        // vanilla errors back to the client.\n\n        if (typeof SimpleSchema.validationErrorTransform === 'function') {\n          throw SimpleSchema.validationErrorTransform(error);\n        } else {\n          throw error;\n        }\n      });\n    }\n    /**\n     * @param obj {Object} Object to validate.\n     * @param [options] {Object} Same options object that ValidationContext#validate takes\n     *\n     * Returns a Promise that resolves with the errors\n     */\n\n  }, {\n    key: 'validateAndReturnErrorsPromise',\n    value: function validateAndReturnErrorsPromise(obj, options) {\n      var _this10 = this;\n\n      var validationContext = this.newContext();\n      var isValid = validationContext.validate(obj, options);\n      if (isValid) return Promise.resolve([]); // Add the `message` prop\n\n      var errors = validationContext.validationErrors().map(function (errorDetail) {\n        return _extends({}, errorDetail, {\n          message: _this10.messageForError(errorDetail)\n        });\n      });\n      return Promise.resolve(errors);\n    }\n  }, {\n    key: 'validator',\n    value: function validator() {\n      var _this11 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return function (obj) {\n        var optionsClone = _extends({}, options);\n\n        if (options.clean === true) {\n          // Do this here and pass into both functions for better performance\n          optionsClone.mongoObject = new _mongoObject2.default(obj, _this11.blackboxKeys());\n\n          _this11.clean(obj, optionsClone);\n        }\n\n        if (options.returnErrorsPromise) {\n          return _this11.validateAndReturnErrorsPromise(obj, optionsClone);\n        }\n\n        return _this11.validate(obj, optionsClone);\n      };\n    }\n  }, {\n    key: 'getFormValidator',\n    value: function getFormValidator() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.validator(_extends({}, options, {\n        returnErrorsPromise: true\n      }));\n    }\n  }, {\n    key: 'clean',\n    value: function clean() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _clean3.default.apply(undefined, [this].concat(args));\n    }\n    /**\n     * Change schema labels on the fly, causing mySchema.label computation\n     * to rerun. Useful when the user changes the language.\n     *\n     * @param {Object} labels A dictionary of all the new label values, by schema key.\n     */\n\n  }, {\n    key: 'labels',\n    value: function labels(_labels) {\n      var _this12 = this;\n\n      Object.keys(_labels).forEach(function (key) {\n        var label = _labels[key];\n        if (typeof label !== 'string' && typeof label !== 'function') return;\n        if (!_this12._schema.hasOwnProperty(key)) return;\n        _this12._schema[key].label = label;\n        _this12._depsLabels[key] && _this12._depsLabels[key].changed();\n      });\n    }\n    /**\n     * Gets a field's label or all field labels reactively.\n     *\n     * @param {String} [key] The schema key, specific or generic.\n     *   Omit this argument to get a dictionary of all labels.\n     * @returns {String} The label\n     */\n\n  }, {\n    key: 'label',\n    value: function label(key) {\n      var _this13 = this; // Get all labels\n\n\n      if (key === null || key === undefined) {\n        var result = {};\n\n        this._schemaKeys.forEach(function (schemaKey) {\n          result[schemaKey] = _this13.label(schemaKey);\n        });\n\n        return result;\n      } // Get label for one field\n\n\n      var label = this.get(key, 'label');\n      if (label) this.reactiveLabelDependency(key);\n      return label || null;\n    }\n    /**\n     * Gets a field's property\n     *\n     * @param {String} key The schema key, specific or generic.\n     * @param {String} prop Name of the property to get for that schema key\n     * @param {Object} [functionContext] The `this` context to use if prop is a function\n     * @returns {any} The property value\n     */\n\n  }, {\n    key: 'get',\n    value: function get(key, prop, functionContext) {\n      var def = this.getDefinition(key, ['type', prop], functionContext);\n      if (!def) return undefined;\n\n      if ((0, _lodash4.default)(schemaDefinitionOptions, prop)) {\n        return def[prop];\n      }\n\n      return (def.type.find(function (props) {\n        return props[prop];\n      }) || {})[prop];\n    } // shorthand for getting defaultValue\n\n  }, {\n    key: 'defaultValue',\n    value: function defaultValue(key) {\n      return this.get(key, 'defaultValue');\n    } // Returns a string message for the given error type and key. Passes through\n    // to message-box pkg.\n\n  }, {\n    key: 'messageForError',\n    value: function messageForError(errorInfo) {\n      var name = errorInfo.name;\n      return this.messageBox.message(errorInfo, {\n        context: {\n          key: name,\n          // backward compatibility\n          // The call to this.label() establishes a reactive dependency, too\n          label: this.label(name)\n        }\n      });\n    }\n    /**\n     * @method SimpleSchema#pick\n     * @param {[fields]} The list of fields to pick to instantiate the subschema\n     * @returns {SimpleSchema} The subschema\n     */\n\n    /**\n     * @method SimpleSchema#omit\n     * @param {[fields]} The list of fields to omit to instantiate the subschema\n     * @returns {SimpleSchema} The subschema\n     */\n\n  }], [{\n    key: 'isSimpleSchema',\n    value: function isSimpleSchema(obj) {\n      return obj && (obj instanceof SimpleSchema || obj._schema);\n    }\n  }, {\n    key: 'extendOptions',\n    // If you need to allow properties other than those listed above, call this from your app or package\n    value: function extendOptions(options) {\n      // For backwards compatibility we still take an object here, but we only care about the names\n      if (!Array.isArray(options)) options = Object.keys(options);\n      options.forEach(function (option) {\n        schemaDefinitionOptions.push(option);\n      });\n    }\n  }, {\n    key: 'defineValidationErrorTransform',\n    value: function defineValidationErrorTransform(transform) {\n      if (typeof transform !== 'function') {\n        throw new Error('SimpleSchema.defineValidationErrorTransform must be passed a function that accepts an Error and returns an Error');\n      }\n\n      SimpleSchema.validationErrorTransform = transform;\n    }\n  }, {\n    key: 'validate',\n    value: function validate(obj, schema, options) {\n      // Allow passing just the schema object\n      if (!SimpleSchema.isSimpleSchema(schema)) {\n        schema = new SimpleSchema(schema);\n      }\n\n      return schema.validate(obj, options);\n    }\n  }, {\n    key: 'oneOf',\n    value: function oneOf() {\n      for (var _len2 = arguments.length, definitions = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        definitions[_key2] = arguments[_key2];\n      }\n\n      return new (Function.prototype.bind.apply(_SimpleSchemaGroup2.default, [null].concat(definitions)))();\n    } // Global custom validators\n\n  }, {\n    key: 'addValidator',\n    value: function addValidator(func) {\n      SimpleSchema._validators.push(func);\n    }\n  }, {\n    key: 'addDocValidator',\n    value: function addDocValidator(func) {\n      SimpleSchema._docValidators.push(func);\n    } // Backwards compatibility\n\n  }]);\n\n  return SimpleSchema;\n}();\n/*\n * PRIVATE\n */\n// Throws an error if any fields are `type` SimpleSchema but then also\n// have subfields defined outside of that.\n\n\nSimpleSchema.version = 2;\nSimpleSchema.RegEx = _regExp2.default;\nSimpleSchema._validators = [];\nSimpleSchema._docValidators = [];\nSimpleSchema.ErrorTypes = {\n  REQUIRED: 'required',\n  MIN_STRING: 'minString',\n  MAX_STRING: 'maxString',\n  MIN_NUMBER: 'minNumber',\n  MAX_NUMBER: 'maxNumber',\n  MIN_NUMBER_EXCLUSIVE: 'minNumberExclusive',\n  MAX_NUMBER_EXCLUSIVE: 'maxNumberExclusive',\n  MIN_DATE: 'minDate',\n  MAX_DATE: 'maxDate',\n  BAD_DATE: 'badDate',\n  MIN_COUNT: 'minCount',\n  MAX_COUNT: 'maxCount',\n  MUST_BE_INTEGER: 'noDecimal',\n  VALUE_NOT_ALLOWED: 'notAllowed',\n  EXPECTED_TYPE: 'expectedType',\n  FAILED_REGULAR_EXPRESSION: 'regEx',\n  KEY_NOT_IN_SCHEMA: 'keyNotInSchema'\n};\nSimpleSchema.Integer = 'SimpleSchema.Integer';\nSimpleSchema._makeGeneric = _mongoObject2.default.makeKeyGeneric;\nSimpleSchema.ValidationContext = _ValidationContext2.default;\n\nSimpleSchema.setDefaultMessages = function (messages) {\n  (0, _extend3.default)(true, _defaultMessages2.default, messages);\n};\n\nfunction checkSchemaOverlap(schema) {\n  Object.keys(schema).forEach(function (key) {\n    var val = schema[key];\n    if (!val.type) throw new Error(key + ' key is missing \"type\"');\n    val.type.definitions.forEach(function (def) {\n      if (!SimpleSchema.isSimpleSchema(def.type)) return;\n      Object.keys(def.type._schema).forEach(function (subKey) {\n        var newKey = key + '.' + subKey;\n\n        if (schema.hasOwnProperty(newKey)) {\n          throw new Error('The type for \"' + key + '\" is set to a SimpleSchema instance that defines \"' + key + '.' + subKey + '\", but the parent SimpleSchema instance also tries to define \"' + key + '.' + subKey + '\"');\n        }\n      });\n    });\n  });\n}\n/**\n * @param {String} fieldName The full generic schema key\n * @param {Boolean} shouldHumanize Humanize it\n * @returns {String} A label based on the key\n */\n\n\nfunction inflectedLabel(fieldName, shouldHumanize) {\n  var pieces = fieldName.split('.');\n  var label = void 0;\n\n  do {\n    label = pieces.pop();\n  } while (label === '$' && pieces.length);\n\n  return shouldHumanize ? (0, _humanize2.default)(label) : label;\n}\n\nfunction getDefaultAutoValueFunction(defaultValue) {\n  return function defaultAutoValueFunction() {\n    if (this.isSet) return;\n    if (this.operator === null) return defaultValue; // Handle the case when pulling an object from an array the object contains a field\n    // which has a defaultValue. We don't want the default value to be returned in this case\n\n    if (this.operator === '$pull') return; // Handle the case where we are $pushing an object into an array of objects and we\n    // want any fields missing from that object to be added if they have default values\n\n    if (this.operator === '$push') return defaultValue; // If parent is set, we should update this position instead of $setOnInsert\n\n    if (this.parentField().isSet) return defaultValue; // Make sure the default value is added on upsert insert\n\n    if (this.isUpsert) return {\n      $setOnInsert: defaultValue\n    };\n  };\n} // Mutates def into standardized object with SimpleSchemaGroup type\n\n\nfunction standardizeDefinition(def) {\n  var standardizedDef = (0, _lodash8.default)(def, oneOfProps); // Internally, all definition types are stored as groups for simplicity of access.\n  // If we are extending, there may not actually be def.type, but it's okay because\n  // it will be added later when the two SimpleSchemaGroups are merged.\n\n  if (def.type && def.type instanceof _SimpleSchemaGroup2.default) {\n    standardizedDef.type = def.type.clone();\n  } else {\n    var groupProps = (0, _lodash10.default)(def, oneOfProps);\n    standardizedDef.type = new _SimpleSchemaGroup2.default(groupProps);\n  }\n\n  return standardizedDef;\n} // Checks and mutates definition. Clone it first.\n\n\nfunction checkAndScrubDefinition(fieldName, definition, options, fullSchemaObj) {\n  if (!definition.type) throw new Error(fieldName + ' key is missing \"type\"'); // Validate the field definition\n\n  Object.keys(definition).forEach(function (key) {\n    if (schemaDefinitionOptions.indexOf(key) === -1) {\n      throw new Error('Invalid definition for ' + fieldName + ' field: \"' + key + '\" is not a supported property');\n    }\n  }); // Make sure the `type`s are OK\n\n  var couldBeArray = false;\n  definition.type.definitions.forEach(function (_ref4) {\n    var type = _ref4.type;\n    if (!type) throw new Error('Invalid definition for ' + fieldName + ' field: \"type\" option is required');\n\n    if (Array.isArray(type)) {\n      throw new Error('Invalid definition for ' + fieldName + ' field: \"type\" may not be an array. Change it to Array.');\n    }\n\n    if (type.constructor === Object && (0, _lodash6.default)(type)) {\n      throw new Error('Invalid definition for ' + fieldName + ' field: \"type\" may not be an object. Change it to Object');\n    }\n\n    if (type === Array) couldBeArray = true;\n\n    if (SimpleSchema.isSimpleSchema(type)) {\n      Object.keys(type._schema).forEach(function (subKey) {\n        var newKey = fieldName + '.' + subKey;\n\n        if (fullSchemaObj.hasOwnProperty(newKey)) {\n          throw new Error('The type for \"' + fieldName + '\" is set to a SimpleSchema instance that defines \"' + newKey + '\", but the parent SimpleSchema instance also tries to define \"' + newKey + '\"');\n        }\n      });\n    }\n  }); // If at least one of the possible types is Array, then make sure we have a\n  // definition for the array items, too.\n\n  if (couldBeArray && !fullSchemaObj.hasOwnProperty(fieldName + '.$')) {\n    throw new Error('\"' + fieldName + '\" is Array type but the schema does not include a \"' + fieldName + '.$\" definition for the array items\"');\n  } // defaultValue -> autoValue\n  // We support defaultValue shortcut by converting it immediately into an\n  // autoValue.\n\n\n  if ('defaultValue' in definition) {\n    if ('autoValue' in definition && !definition.autoValue.isDefault) {\n      console.warn('SimpleSchema: Found both autoValue and defaultValue options for \"' + fieldName + '\". Ignoring defaultValue.');\n    } else {\n      if (fieldName.endsWith('.$')) {\n        throw new Error('An array item field (one that ends with \".$\") cannot have defaultValue.');\n      }\n\n      definition.autoValue = getDefaultAutoValueFunction(definition.defaultValue);\n      definition.autoValue.isDefault = true;\n    }\n  } // REQUIREDNESS\n\n\n  if (fieldName.endsWith('.$')) {\n    definition.optional = true;\n  } else {\n    if (!definition.hasOwnProperty('optional')) {\n      if (definition.hasOwnProperty('required')) {\n        if (typeof definition.required === 'function') {\n          definition.optional = function optional() {\n            for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n              args[_key3] = arguments[_key3];\n            }\n\n            return !definition.required.apply(this, args);\n          };\n        } else {\n          definition.optional = !definition.required;\n        }\n      } else {\n        definition.optional = options.requiredByDefault === false;\n      }\n    }\n  }\n\n  delete definition.required; // LABELS\n\n  if (!definition.hasOwnProperty('label')) {\n    if (options.defaultLabel) {\n      definition.label = options.defaultLabel;\n    } else if (SimpleSchema.defaultLabel) {\n      definition.label = SimpleSchema.defaultLabel;\n    } else {\n      definition.label = inflectedLabel(fieldName, options.humanizeAutoLabels);\n    }\n  }\n}\n\nfunction getPickOrOmit(type) {\n  return function pickOrOmit() {\n    var _this14 = this;\n\n    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    } // If they are picking/omitting an object or array field, we need to also include everything under it\n\n\n    var newSchema = {};\n\n    this._schemaKeys.forEach(function (key) {\n      // Pick/omit it if it IS in the array of keys they want OR if it\n      // STARTS WITH something that is in the array plus a period\n      var includeIt = args.some(function (wantedField) {\n        return key === wantedField || key.indexOf(wantedField + '.') === 0;\n      });\n\n      if (includeIt && type === 'pick' || !includeIt && type === 'omit') {\n        newSchema[key] = _this14._schema[key];\n      }\n    });\n\n    return this._copyWithSchema(newSchema);\n  };\n}\n\nexports.SimpleSchema = SimpleSchema;\nexports.ValidationContext = _ValidationContext2.default;","map":null,"metadata":{},"sourceType":"script"}