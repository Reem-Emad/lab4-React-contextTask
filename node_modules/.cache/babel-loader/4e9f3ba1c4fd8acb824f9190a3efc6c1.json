{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _lodash = require('lodash.foreach');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _lodash3 = require('lodash.isempty');\n\nvar _lodash4 = _interopRequireDefault(_lodash3);\n\nvar _lodash5 = require('lodash.isobject');\n\nvar _lodash6 = _interopRequireDefault(_lodash5);\n\nvar _lodash7 = require('lodash.without');\n\nvar _lodash8 = _interopRequireDefault(_lodash7);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar REMOVED_MARKER = '______MONGO_OBJECT_REMOVED______';\n\nvar MongoObject = function () {\n  /*\n   * @constructor\n   * @param {Object} obj\n   * @param {string[]}  blackboxKeys  - A list of the names of keys that shouldn't be traversed\n   * @returns {undefined}\n   *\n   * Creates a new MongoObject instance. The object passed as the first argument\n   * will be modified in place by calls to instance methods. Also, immediately\n   * upon creation of the instance, the object will have any `undefined` keys\n   * removed recursively.\n   */\n  function MongoObject(obj) {\n    var blackboxKeys = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n    _classCallCheck(this, MongoObject);\n\n    this._obj = obj;\n    this._blackboxKeys = blackboxKeys;\n\n    this._reParseObj();\n  }\n\n  _createClass(MongoObject, [{\n    key: '_reParseObj',\n    value: function _reParseObj() {\n      var blackboxKeys = this._blackboxKeys;\n      this._affectedKeys = {};\n      this._genericAffectedKeys = {};\n      this._positionsByGenericKey = {};\n      this._positionsThatCreateGenericKey = {};\n      this._parentPositions = [];\n      this._positionsInsideArrays = [];\n      this._objectPositions = [];\n      this._arrayItemPositions = [];\n\n      function parseObj(self, val, currentPosition, affectedKey, operator, adjusted, isWithinArray) {\n        // Adjust for first-level modifier operators\n        if (!operator && affectedKey && affectedKey.substring(0, 1) === '$') {\n          operator = affectedKey;\n          affectedKey = null;\n        }\n\n        var affectedKeyIsBlackBox = false;\n        var stop = false;\n\n        if (affectedKey) {\n          // Adjust for $push and $addToSet and $pull and $pop\n          if (!adjusted) {\n            if (operator === '$push' || operator === '$addToSet' || operator === '$pop') {\n              // Adjust for $each\n              // We can simply jump forward and pretend like the $each array\n              // is the array for the field. This has the added benefit of\n              // skipping past any $slice, which we also don't care about.\n              if (MongoObject.isBasicObject(val) && '$each' in val) {\n                val = val.$each;\n                currentPosition = currentPosition + '[$each]';\n              } else {\n                affectedKey = affectedKey + '.0';\n              }\n\n              adjusted = true;\n            } else if (operator === '$pull') {\n              affectedKey = affectedKey + '.0';\n\n              if (MongoObject.isBasicObject(val)) {\n                stop = true;\n              }\n\n              adjusted = true;\n            }\n          } // Make generic key\n\n\n          var affectedKeyGeneric = MongoObject.makeKeyGeneric(affectedKey); // Determine whether affected key should be treated as a black box\n\n          affectedKeyIsBlackBox = blackboxKeys.indexOf(affectedKeyGeneric) > -1; // Mark that this position affects this generic and non-generic key\n\n          if (currentPosition) {\n            (function () {\n              self._affectedKeys[currentPosition] = affectedKey;\n              self._genericAffectedKeys[currentPosition] = affectedKeyGeneric;\n              var positionInfo = {\n                key: affectedKey,\n                operator: operator || null,\n                position: currentPosition\n              };\n              if (!self._positionsByGenericKey[affectedKeyGeneric]) self._positionsByGenericKey[affectedKeyGeneric] = [];\n\n              self._positionsByGenericKey[affectedKeyGeneric].push(positionInfo); // Operators other than $unset will cause ancestor object keys to\n              // be auto-created.\n\n\n              if (operator && operator !== '$unset') {\n                MongoObject.objectsThatGenericKeyWillCreate(affectedKeyGeneric).forEach(function (objGenericKey) {\n                  if (!self._positionsThatCreateGenericKey[objGenericKey]) {\n                    self._positionsThatCreateGenericKey[objGenericKey] = [];\n                  }\n\n                  self._positionsThatCreateGenericKey[objGenericKey].push(positionInfo);\n                });\n              } // If we're within an array, mark this position so we can omit it from flat docs\n\n\n              if (isWithinArray) self._positionsInsideArrays.push(currentPosition);\n            })();\n          }\n        }\n\n        if (stop) return; // Loop through arrays\n\n        if (Array.isArray(val) && val.length > 0) {\n          if (currentPosition) {\n            // Mark positions with arrays that should be ignored when we want endpoints only\n            self._parentPositions.push(currentPosition);\n          } // Loop\n\n\n          (0, _lodash2.default)(val, function (v, i) {\n            if (currentPosition) self._arrayItemPositions.push(currentPosition + '[' + i + ']');\n            parseObj(self, v, currentPosition ? currentPosition + '[' + i + ']' : i, affectedKey + '.' + i, operator, adjusted, true);\n          });\n        } else if (MongoObject.isBasicObject(val) && !affectedKeyIsBlackBox || !currentPosition) {\n          // Loop through object keys, only for basic objects,\n          // but always for the passed-in object, even if it\n          // is a custom object.\n          if (currentPosition && !(0, _lodash4.default)(val)) {\n            // Mark positions with objects that should be ignored when we want endpoints only\n            self._parentPositions.push(currentPosition); // Mark positions with objects that should be left out of flat docs.\n\n\n            self._objectPositions.push(currentPosition);\n          } // Loop\n\n\n          Object.keys(val).forEach(function (k) {\n            var v = val[k];\n\n            if (v === void 0) {\n              delete val[k];\n            } else if (k !== '$slice') {\n              parseObj(self, v, currentPosition ? currentPosition + '[' + k + ']' : k, appendAffectedKey(affectedKey, k), operator, adjusted, isWithinArray);\n            }\n          });\n        }\n      }\n\n      parseObj(this, this._obj);\n    }\n    /**\n     * @method MongoObject.forEachNode\n     * @param {Function} func\n     * @param {Object} [options]\n     * @param {Boolean} [options.endPointsOnly=true] - Only call function for endpoints and not for nodes that contain other nodes\n     * @returns {undefined}\n     *\n     * Runs a function for each endpoint node in the object tree, including all items in every array.\n     * The function arguments are\n     * (1) the value at this node\n     * (2) a string representing the node position\n     * (3) the representation of what would be changed in mongo, using mongo dot notation\n     * (4) the generic equivalent of argument 3, with '$' instead of numeric pieces\n     */\n\n  }, {\n    key: 'forEachNode',\n    value: function forEachNode(func) {\n      var _this = this;\n\n      var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var _ref$endPointsOnly = _ref.endPointsOnly;\n      var endPointsOnly = _ref$endPointsOnly === undefined ? true : _ref$endPointsOnly;\n      if (typeof func !== 'function') throw new Error('filter requires a loop function');\n      var updatedValues = {};\n      Object.keys(this._affectedKeys).forEach(function (position) {\n        if (endPointsOnly && _this._parentPositions.indexOf(position) > -1) return; // Only endpoints\n\n        func.call({\n          value: _this.getValueForPosition(position),\n          isArrayItem: _this._arrayItemPositions.indexOf(position) > -1,\n          operator: extractOp(position),\n          position: position,\n          key: _this._affectedKeys[position],\n          genericKey: _this._genericAffectedKeys[position],\n          updateValue: function updateValue(newVal) {\n            updatedValues[position] = newVal;\n          },\n          remove: function remove() {\n            updatedValues[position] = undefined;\n          }\n        });\n      }); // Actually update/remove values as instructed\n\n      Object.keys(updatedValues).forEach(function (position) {\n        _this.setValueForPosition(position, updatedValues[position]);\n      });\n    }\n  }, {\n    key: 'getValueForPosition',\n    value: function getValueForPosition(position) {\n      var subkeys = position.split('[');\n      var current = this._obj;\n      var ln = subkeys.length;\n\n      for (var i = 0; i < ln; i++) {\n        var subkey = subkeys[i]; // If the subkey ends in ']', remove the ending\n\n        if (subkey.slice(-1) === ']') subkey = subkey.slice(0, -1);\n        current = current[subkey];\n        if (!Array.isArray(current) && !MongoObject.isBasicObject(current) && i < ln - 1) return;\n      }\n\n      if (current === REMOVED_MARKER) return;\n      return current;\n    }\n    /**\n     * @method MongoObject.prototype.setValueForPosition\n     * @param {String} position\n     * @param {Any} value\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'setValueForPosition',\n    value: function setValueForPosition(position, value) {\n      var subkeys = position.split('[');\n      var current = this._obj;\n      var ln = subkeys.length;\n      var createdObjectsOrArrays = false;\n\n      for (var i = 0; i < ln; i++) {\n        var subkey = subkeys[i]; // If the subkey ends in \"]\", remove the ending\n\n        if (subkey.slice(-1) === ']') subkey = subkey.slice(0, -1); // If we've reached the key in the object tree that needs setting or\n        // deleting, do it.\n\n        if (i === ln - 1) {\n          // If value is undefined, delete the property\n          if (value === undefined) {\n            if (Array.isArray(current)) {\n              // We can't just delete it because indexes in the position strings will be off\n              // We will mark it uniquely and then parse this elsewhere\n              current[subkey] = REMOVED_MARKER;\n            } else {\n              delete current[subkey];\n            }\n          } else {\n            current[subkey] = value;\n          }\n        } else {\n          // Otherwise attempt to keep moving deeper into the object.\n          // If we're setting (as opposed to deleting) a key and we hit a place\n          // in the ancestor chain where the keys are not yet created, create them.\n          if (current[subkey] === undefined && value !== undefined) {\n            // See if the next piece is a number\n            var nextPiece = subkeys[i + 1];\n            nextPiece = parseInt(nextPiece, 10);\n            current[subkey] = isNaN(nextPiece) ? {} : [];\n            createdObjectsOrArrays = true;\n          } // Move deeper into the object\n\n\n          current = current[subkey]; // If we can go no further, then quit\n\n          if (!Array.isArray(current) && !MongoObject.isBasicObject(current) && i < ln - 1) return;\n        }\n      } // If there are now new arrays or objects in the main object, we need to reparse it\n\n\n      if (createdObjectsOrArrays || Array.isArray(value) || MongoObject.isBasicObject(value)) {\n        this._reParseObj();\n      }\n    }\n    /**\n     * @method MongoObject.prototype.removeValueForPosition\n     * @param {String} position\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'removeValueForPosition',\n    value: function removeValueForPosition(position) {\n      this.setValueForPosition(position, undefined);\n    }\n    /**\n     * @method MongoObject.prototype.getKeyForPosition\n     * @param {String} position\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'getKeyForPosition',\n    value: function getKeyForPosition(position) {\n      return this._affectedKeys[position];\n    }\n    /**\n     * @method MongoObject.prototype.getGenericKeyForPosition\n     * @param {String} position\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'getGenericKeyForPosition',\n    value: function getGenericKeyForPosition(position) {\n      return this._genericAffectedKeys[position];\n    }\n    /**\n     * @method MongoObject.getInfoForKey\n     * @param {String} key - Non-generic key\n     * @returns {undefined|Object}\n     *\n     * Returns the value and operator of the requested non-generic key.\n     * Example: {value: 1, operator: \"$pull\"}\n     */\n\n  }, {\n    key: 'getInfoForKey',\n    value: function getInfoForKey(key) {\n      // Get the info\n      var position = this.getPositionForKey(key);\n\n      if (position) {\n        return {\n          value: this.getValueForPosition(position),\n          operator: extractOp(position)\n        };\n      } // If we haven't returned yet, check to see if there is an array value\n      // corresponding to this key\n      // We find the first item within the array, strip the last piece off the\n      // position string, and then return whatever is at that new position in\n      // the original object.\n\n\n      var positions = this.getPositionsForGenericKey(key + '.$');\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = positions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var pos = _step.value;\n          var value = this.getValueForPosition(pos);\n\n          if (value === undefined) {\n            var parentPosition = pos.slice(0, pos.lastIndexOf('['));\n            value = this.getValueForPosition(parentPosition);\n          }\n\n          if (value !== undefined) {\n            return {\n              value: value,\n              operator: extractOp(pos)\n            };\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * @method MongoObject.getPositionForKey\n     * @param {String} key - Non-generic key\n     * @returns {undefined|String} Position string\n     *\n     * Returns the position string for the place in the object that\n     * affects the requested non-generic key.\n     * Example: 'foo[bar][0]'\n     */\n\n  }, {\n    key: 'getPositionForKey',\n    value: function getPositionForKey(key) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = Object.getOwnPropertyNames(this._affectedKeys)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var position = _step2.value; // We return the first one we find. While it's\n          // possible that multiple update operators could\n          // affect the same non-generic key, we'll assume that's not the case.\n\n          if (this._affectedKeys[position] === key) return position;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n    /**\n     * @method MongoObject.getPositionsForGenericKey\n     * @param {String} genericKey - Generic key\n     * @returns {String[]} Array of position strings\n     *\n     * Returns an array of position strings for the places in the object that\n     * affect the requested generic key.\n     * Example: ['foo[bar][0]']\n     */\n\n  }, {\n    key: 'getPositionsForGenericKey',\n    value: function getPositionsForGenericKey(genericKey) {\n      return this.getPositionsInfoForGenericKey(genericKey).map(function (p) {\n        return p.position;\n      });\n    }\n    /**\n     * @method MongoObject.getPositionsInfoForGenericKey\n     * @param {String} genericKey - Generic key\n     * @returns {Object[]} Array of position info objects\n     *\n     * Returns an array of position info for the places in the object that\n     * affect the requested generic key.\n     */\n\n  }, {\n    key: 'getPositionsInfoForGenericKey',\n    value: function getPositionsInfoForGenericKey(genericKey) {\n      var _this2 = this;\n\n      var positions = this._positionsByGenericKey[genericKey];\n      if (!positions || positions.length === 0) positions = this._positionsByGenericKey[genericKey + '.$'];\n      if (!positions || positions.length === 0) positions = [];\n      return positions.map(function (info) {\n        return Object.assign({\n          value: _this2.getValueForPosition(info.position)\n        }, info);\n      });\n    }\n  }, {\n    key: 'getPositionsThatCreateGenericKey',\n    value: function getPositionsThatCreateGenericKey(genericKey) {\n      return this._positionsThatCreateGenericKey[genericKey] || [];\n    }\n    /**\n     * @deprecated Use getInfoForKey\n     * @method MongoObject.getValueForKey\n     * @param {String} key - Non-generic key\n     * @returns {undefined|Any}\n     *\n     * Returns the value of the requested non-generic key\n     */\n\n  }, {\n    key: 'getValueForKey',\n    value: function getValueForKey(key) {\n      var position = this.getPositionForKey(key);\n      if (position) return this.getValueForPosition(position);\n    }\n    /**\n     * @method MongoObject.prototype.addKey\n     * @param {String} key - Key to set\n     * @param {Any} val - Value to give this key\n     * @param {String} op - Operator under which to set it, or `null` for a non-modifier object\n     * @returns {undefined}\n     *\n     * Adds `key` with value `val` under operator `op` to the source object.\n     */\n\n  }, {\n    key: 'addKey',\n    value: function addKey(key, val, op) {\n      var position = op ? op + '[' + key + ']' : MongoObject._keyToPosition(key);\n      this.setValueForPosition(position, val);\n    }\n    /**\n     * @method MongoObject.prototype.removeGenericKeys\n     * @param {String[]} keys\n     * @returns {undefined}\n     *\n     * Removes anything that affects any of the generic keys in the list\n     */\n\n  }, {\n    key: 'removeGenericKeys',\n    value: function removeGenericKeys(keys) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = Object.getOwnPropertyNames(this._genericAffectedKeys)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var position = _step3.value;\n\n          if (keys.indexOf(this._genericAffectedKeys[position]) > -1) {\n            this.removeValueForPosition(position);\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n    /**\n     * @method MongoObject.removeGenericKey\n     * @param {String} key\n     * @returns {undefined}\n     *\n     * Removes anything that affects the requested generic key\n     */\n\n  }, {\n    key: 'removeGenericKey',\n    value: function removeGenericKey(key) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = Object.getOwnPropertyNames(this._genericAffectedKeys)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var position = _step4.value;\n\n          if (this._genericAffectedKeys[position] === key) {\n            this.removeValueForPosition(position);\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n    /**\n     * @method MongoObject.removeKey\n     * @param {String} key\n     * @returns {undefined}\n     *\n     * Removes anything that affects the requested non-generic key\n     */\n\n  }, {\n    key: 'removeKey',\n    value: function removeKey(key) {\n      // We don't use getPositionForKey here because we want to be sure to\n      // remove for all positions if there are multiple.\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = Object.getOwnPropertyNames(this._affectedKeys)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var position = _step5.value;\n\n          if (this._affectedKeys[position] === key) {\n            this.removeValueForPosition(position);\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    }\n    /**\n     * @method MongoObject.removeKeys\n     * @param {String[]} keys\n     * @returns {undefined}\n     *\n     * Removes anything that affects any of the non-generic keys in the list\n     */\n\n  }, {\n    key: 'removeKeys',\n    value: function removeKeys(keys) {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = keys[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var key = _step6.value;\n          this.removeKey(key);\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n    /**\n     * @method MongoObject.filterGenericKeys\n     * @param {Function} test - Test function\n     * @returns {undefined}\n     *\n     * Passes all affected keys to a test function, which\n     * should return false to remove whatever is affecting that key\n     */\n\n  }, {\n    key: 'filterGenericKeys',\n    value: function filterGenericKeys(test) {\n      var checkedKeys = [];\n      var keysToRemove = [];\n\n      for (var position in this._genericAffectedKeys) {\n        if (this._genericAffectedKeys.hasOwnProperty(position)) {\n          var genericKey = this._genericAffectedKeys[position];\n\n          if (checkedKeys.indexOf(genericKey) === -1) {\n            checkedKeys.push(genericKey);\n\n            if (genericKey && !test(genericKey)) {\n              keysToRemove.push(genericKey);\n            }\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = keysToRemove[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var key = _step7.value;\n          this.removeGenericKey(key);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    }\n    /**\n     * @method MongoObject.setValueForKey\n     * @param {String} key\n     * @param {Any} val\n     * @returns {undefined}\n     *\n     * Sets the value for every place in the object that affects\n     * the requested non-generic key\n     */\n\n  }, {\n    key: 'setValueForKey',\n    value: function setValueForKey(key, val) {\n      // We don't use getPositionForKey here because we want to be sure to\n      // set the value for all positions if there are multiple.\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = Object.getOwnPropertyNames(this._affectedKeys)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var position = _step8.value;\n\n          if (this._affectedKeys[position] === key) {\n            this.setValueForPosition(position, val);\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n    /**\n     * @method MongoObject.setValueForGenericKey\n     * @param {String} key\n     * @param {Any} val\n     * @returns {undefined}\n     *\n     * Sets the value for every place in the object that affects\n     * the requested generic key\n     */\n\n  }, {\n    key: 'setValueForGenericKey',\n    value: function setValueForGenericKey(key, val) {\n      // We don't use getPositionForKey here because we want to be sure to\n      // set the value for all positions if there are multiple.\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = Object.getOwnPropertyNames(this._genericAffectedKeys)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var position = _step9.value;\n\n          if (this._genericAffectedKeys[position] === key) {\n            this.setValueForPosition(position, val);\n          }\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'removeArrayItems',\n    value: function removeArrayItems() {\n      // Traverse and pull out removed array items at this point\n      function traverse(obj) {\n        (0, _lodash2.default)(obj, function (val, indexOrProp) {\n          // Move deeper into the object\n          var next = obj[indexOrProp]; // If we can go no further, then quit\n\n          if (MongoObject.isBasicObject(next)) {\n            traverse(next);\n          } else if (Array.isArray(next)) {\n            obj[indexOrProp] = (0, _lodash8.default)(next, REMOVED_MARKER);\n            traverse(obj[indexOrProp]);\n          }\n        });\n      }\n\n      traverse(this._obj);\n    }\n    /**\n     * @method MongoObject.getObject\n     * @returns {Object}\n     *\n     * Get the source object, potentially modified by other method calls on this\n     * MongoObject instance.\n     */\n\n  }, {\n    key: 'getObject',\n    value: function getObject() {\n      return this._obj;\n    }\n    /**\n     * @method MongoObject.getFlatObject\n     * @returns {Object}\n     *\n     * Gets a flat object based on the MongoObject instance.\n     * In a flat object, the key is the name of the non-generic affectedKey,\n     * with mongo dot notation if necessary, and the value is the value for\n     * that key.\n     *\n     * With `keepArrays: true`, we don't flatten within arrays. Currently\n     * MongoDB does not see a key such as `a.0.b` and automatically assume\n     * an array. Instead it would create an object with key '0' if there\n     * wasn't already an array saved as the value of `a`, which is rarely\n     * if ever what we actually want. To avoid this confusion, we\n     * set entire arrays.\n     */\n\n  }, {\n    key: 'getFlatObject',\n    value: function getFlatObject() {\n      var _this3 = this;\n\n      var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var _ref2$keepArrays = _ref2.keepArrays;\n      var keepArrays = _ref2$keepArrays === undefined ? false : _ref2$keepArrays;\n      var newObj = {};\n      Object.keys(this._affectedKeys).forEach(function (position) {\n        var affectedKey = _this3._affectedKeys[position];\n\n        if (typeof affectedKey === 'string' && keepArrays === true && _this3._positionsInsideArrays.indexOf(position) === -1 && _this3._objectPositions.indexOf(position) === -1 || keepArrays !== true && _this3._parentPositions.indexOf(position) === -1) {\n          newObj[affectedKey] = _this3.getValueForPosition(position);\n        }\n      });\n      return newObj;\n    }\n    /**\n     * @method MongoObject.affectsKey\n     * @param {String} key\n     * @returns {Object}\n     *\n     * Returns true if the non-generic key is affected by this object\n     */\n\n  }, {\n    key: 'affectsKey',\n    value: function affectsKey(key) {\n      return !!this.getPositionForKey(key);\n    }\n    /**\n     * @method MongoObject.affectsGenericKey\n     * @param {String} key\n     * @returns {Object}\n     *\n     * Returns true if the generic key is affected by this object\n     */\n\n  }, {\n    key: 'affectsGenericKey',\n    value: function affectsGenericKey(key) {\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = Object.getOwnPropertyNames(this._genericAffectedKeys)[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var position = _step10.value;\n          if (this._genericAffectedKeys[position] === key) return true;\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * @method MongoObject.affectsGenericKeyImplicit\n     * @param {String} key\n     * @returns {Object}\n     *\n     * Like affectsGenericKey, but will return true if a child key is affected\n     */\n\n  }, {\n    key: 'affectsGenericKeyImplicit',\n    value: function affectsGenericKeyImplicit(key) {\n      var _iteratorNormalCompletion11 = true;\n      var _didIteratorError11 = false;\n      var _iteratorError11 = undefined;\n\n      try {\n        for (var _iterator11 = Object.getOwnPropertyNames(this._genericAffectedKeys)[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n          var position = _step11.value;\n          var affectedKey = this._genericAffectedKeys[position];\n          if (genericKeyAffectsOtherGenericKey(key, affectedKey)) return true;\n        }\n      } catch (err) {\n        _didIteratorError11 = true;\n        _iteratorError11 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion11 && _iterator11.return) {\n            _iterator11.return();\n          }\n        } finally {\n          if (_didIteratorError11) {\n            throw _iteratorError11;\n          }\n        }\n      }\n\n      return false;\n    }\n    /* STATIC */\n\n    /* Takes a specific string that uses mongo-style dot notation\n     * and returns a generic string equivalent. Replaces all numeric\n     * \"pieces\" with a dollar sign ($).\n     *\n     * @param {type} name\n     * @returns {String} Generic name.\n     */\n\n  }], [{\n    key: 'makeKeyGeneric',\n    value: function makeKeyGeneric(key) {\n      if (typeof key !== 'string') return null;\n      return key.replace(/\\.[0-9]+(?=\\.|$)/g, '.$');\n    }\n    /** Takes a string representation of an object key and its value\n     *  and updates \"obj\" to contain that key with that value.\n     *\n     *  Example keys and results if val is 1:\n     *    \"a\" -> {a: 1}\n     *    \"a[b]\" -> {a: {b: 1}}\n     *    \"a[b][0]\" -> {a: {b: [1]}}\n     *    'a[b.0.c]' -> {a: {'b.0.c': 1}}\n     *\n     * @param {any} val\n     * @param {String} key\n     * @param {Object} obj\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'expandKey',\n    value: function expandKey(val, key, obj) {\n      var subkeys = key.split('[');\n      var current = obj;\n\n      for (var i = 0, ln = subkeys.length; i < ln; i++) {\n        var subkey = subkeys[i];\n\n        if (subkey.slice(-1) === ']') {\n          subkey = subkey.slice(0, -1);\n        }\n\n        if (i === ln - 1) {\n          // Last iteration; time to set the value; always overwrite\n          current[subkey] = val; // If val is undefined, delete the property\n\n          if (val === void 0) delete current[subkey];\n        } else {\n          // See if the next piece is a number\n          var nextPiece = subkeys[i + 1];\n          nextPiece = parseInt(nextPiece, 10);\n\n          if (!current[subkey]) {\n            current[subkey] = isNaN(nextPiece) ? {} : [];\n          }\n        }\n\n        current = current[subkey];\n      }\n    }\n  }, {\n    key: '_keyToPosition',\n    value: function _keyToPosition(key, wrapAll) {\n      var position = '';\n      (0, _lodash2.default)(key.split('.'), function (piece, i) {\n        if (i === 0 && !wrapAll) {\n          position += piece;\n        } else {\n          position += '[' + piece + ']';\n        }\n      });\n      return position;\n    }\n    /**\n     * @method MongoObject._positionToKey\n     * @param {String} position\n     * @returns {String} The key that this position in an object would affect.\n     *\n     * This is different from MongoObject.prototype.getKeyForPosition in that\n     * this method does not depend on the requested position actually being\n     * present in any particular MongoObject.\n     */\n\n  }, {\n    key: '_positionToKey',\n    value: function _positionToKey(position) {\n      // XXX Probably a better way to do this, but this is\n      // foolproof for now.\n      var mDoc = new MongoObject({});\n      mDoc.setValueForPosition(position, 1); // Value doesn't matter\n\n      return mDoc.getKeyForPosition(position);\n    }\n    /**\n     * @method MongoObject.cleanNulls\n     * @public\n     * @param {Object} doc - Source object\n     * @returns {Object}\n     *\n     * Returns an object in which all properties with null, undefined, or empty\n     * string values have been removed, recursively.\n     */\n\n  }, {\n    key: 'cleanNulls',\n    value: function cleanNulls(doc, isArray, keepEmptyStrings) {\n      var newDoc = isArray ? [] : {};\n      Object.keys(doc).forEach(function (key) {\n        var val = doc[key];\n\n        if (!Array.isArray(val) && MongoObject.isBasicObject(val)) {\n          val = MongoObject.cleanNulls(val, false, keepEmptyStrings); // Recurse into plain objects\n\n          if (!(0, _lodash4.default)(val)) newDoc[key] = val;\n        } else if (Array.isArray(val)) {\n          val = MongoObject.cleanNulls(val, true, keepEmptyStrings); // Recurse into non-typed arrays\n\n          if (!(0, _lodash4.default)(val)) newDoc[key] = val;\n        } else if (!isNullUndefinedOrEmptyString(val)) {\n          newDoc[key] = val;\n        } else if (keepEmptyStrings && typeof val === 'string' && val.length === 0) {\n          newDoc[key] = val;\n        }\n      });\n      return newDoc;\n    }\n    /**\n     * @method MongoObject.reportNulls\n     * @public\n     * @param {Object} flatDoc - An object with no properties that are also objects.\n     * @returns {Object} An object in which the keys represent the keys in the\n     * original object that were null, undefined, or empty strings, and the value\n     * of each key is \"\".\n     */\n\n  }, {\n    key: 'reportNulls',\n    value: function reportNulls(flatDoc, keepEmptyStrings) {\n      var nulls = {}; // Loop through the flat doc\n\n      Object.keys(flatDoc).forEach(function (key) {\n        var val = flatDoc[key];\n\n        if (val === null || val === undefined || !keepEmptyStrings && typeof val === 'string' && val.length === 0 || // If value is an array in which all the values recursively are undefined, null,\n        // or an empty string\n        Array.isArray(val) && MongoObject.cleanNulls(val, true, keepEmptyStrings).length === 0) {\n          nulls[key] = '';\n        }\n      });\n      return nulls;\n    }\n    /**\n     * @method MongoObject.docToModifier\n     * @public\n     * @param {Object} doc - An object to be converted into a MongoDB modifier\n     * @param {Object} [options] - Options\n     * @param {Boolean} [options.keepEmptyStrings] - Pass `true` to keep empty strings in the $set. Otherwise $unset them.\n     * @param {Boolean} [options.keepArrays] - Pass `true` to $set entire arrays. Otherwise the modifier will $set individual array items.\n     * @returns {Object} A MongoDB modifier.\n     *\n     * Converts an object into a modifier by flattening it, putting keys with\n     * null, undefined, and empty string values into `modifier.$unset`, and\n     * putting the rest of the keys into `modifier.$set`.\n     */\n\n  }, {\n    key: 'docToModifier',\n    value: function docToModifier(doc) {\n      var _ref3 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var _ref3$keepArrays = _ref3.keepArrays;\n      var keepArrays = _ref3$keepArrays === undefined ? false : _ref3$keepArrays;\n      var _ref3$keepEmptyString = _ref3.keepEmptyStrings;\n      var keepEmptyStrings = _ref3$keepEmptyString === undefined ? false : _ref3$keepEmptyString; // Flatten doc\n\n      var mDoc = new MongoObject(doc);\n      var flatDoc = mDoc.getFlatObject({\n        keepArrays: keepArrays\n      }); // Get a list of null, undefined, and empty string values so we can unset them instead\n\n      var nulls = MongoObject.reportNulls(flatDoc, keepEmptyStrings);\n      flatDoc = MongoObject.cleanNulls(flatDoc, false, keepEmptyStrings);\n      var modifier = {};\n      if (!(0, _lodash4.default)(flatDoc)) modifier.$set = flatDoc;\n      if (!(0, _lodash4.default)(nulls)) modifier.$unset = nulls;\n      return modifier;\n    }\n    /* Tests whether \"obj\" is an Object as opposed to\n     * something that inherits from Object\n     *\n     * @param {any} obj\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'isBasicObject',\n    value: function isBasicObject(obj) {\n      return obj === Object(obj) && Object.getPrototypeOf(obj) === Object.prototype;\n    }\n    /**\n     * @method MongoObject.objAffectsKey\n     * @public\n     * @param  {Object} obj\n     * @param  {String} key\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'objAffectsKey',\n    value: function objAffectsKey(obj, key) {\n      var mDoc = new MongoObject(obj);\n      return mDoc.affectsKey(key);\n    }\n    /**\n     * @method MongoObject.objectsThatGenericKeyWillCreate\n     * @public\n     * @param  {String} genericKey\n     * @return {String[]} Array of other generic keys that would be created\n     *                    by this generic key\n     */\n\n  }, {\n    key: 'objectsThatGenericKeyWillCreate',\n    value: function objectsThatGenericKeyWillCreate(genericKey) {\n      var objs = [];\n\n      do {\n        var lastDotPosition = genericKey.lastIndexOf('.');\n        genericKey = lastDotPosition === -1 ? '' : genericKey.slice(0, lastDotPosition);\n        if (genericKey.length && !genericKey.endsWith('.$')) objs.push(genericKey);\n      } while (genericKey.length);\n\n      return objs;\n    }\n    /**\n     * @method MongoObject.expandObj\n     * @public\n     * @param  {Object} doc\n     * @return {Object}\n     *\n     * Takes a flat object and returns an expanded version of it.\n     */\n\n  }, {\n    key: 'expandObj',\n    value: function expandObj(doc) {\n      var newDoc = {};\n      Object.keys(doc).forEach(function (key) {\n        var val = doc[key];\n        var subkeys = key.split('.');\n        var subkeylen = subkeys.length;\n        var current = newDoc;\n\n        for (var i = 0; i < subkeylen; i++) {\n          var subkey = subkeys[i];\n\n          if (typeof current[subkey] !== 'undefined' && !(0, _lodash6.default)(current[subkey])) {\n            break; // Already set for some reason; leave it alone\n          }\n\n          if (i === subkeylen - 1) {\n            // Last iteration; time to set the value\n            current[subkey] = val;\n          } else {\n            // See if the next piece is a number\n            var nextPiece = subkeys[i + 1];\n            nextPiece = parseInt(nextPiece, 10);\n\n            if (isNaN(nextPiece) && !(0, _lodash6.default)(current[subkey])) {\n              current[subkey] = {};\n            } else if (!isNaN(nextPiece) && !Array.isArray(current[subkey])) {\n              current[subkey] = [];\n            }\n          }\n\n          current = current[subkey];\n        }\n      });\n      return newDoc;\n    }\n  }]);\n\n  return MongoObject;\n}();\n/* PRIVATE */\n\n\nexports.default = MongoObject;\n\nfunction appendAffectedKey(affectedKey, key) {\n  if (key === '$each') return affectedKey;\n  return affectedKey ? affectedKey + '.' + key : key;\n} // Extracts operator piece, if present, from position string\n\n\nfunction extractOp(position) {\n  var firstPositionPiece = position.slice(0, position.indexOf('['));\n  return firstPositionPiece.substring(0, 1) === '$' ? firstPositionPiece : null;\n}\n\nfunction genericKeyAffectsOtherGenericKey(key, affectedKey) {\n  // If the affected key is the test key\n  if (affectedKey === key) return true; // If the affected key implies the test key because the affected key\n  // starts with the test key followed by a period\n\n  if (affectedKey.substring(0, key.length + 1) === key + '.') return true; // If the affected key implies the test key because the affected key\n  // starts with the test key and the test key ends with \".$\"\n\n  var lastTwo = key.slice(-2);\n  if (lastTwo === '.$' && key.slice(0, -2) === affectedKey) return true;\n  return false;\n}\n\nfunction isNullUndefinedOrEmptyString(val) {\n  return val === undefined || val === null || typeof val === 'string' && val.length === 0;\n}","map":null,"metadata":{},"sourceType":"script"}