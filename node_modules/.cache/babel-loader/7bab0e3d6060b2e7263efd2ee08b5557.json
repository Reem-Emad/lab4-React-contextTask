{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _mongoObject = require('mongo-object');\n\nvar _mongoObject2 = _interopRequireDefault(_mongoObject);\n\nvar _doValidation = require('./doValidation.js');\n\nvar _doValidation2 = _interopRequireDefault(_doValidation);\n\nvar _lodash = require('lodash.findwhere');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar ValidationContext = function () {\n  function ValidationContext(ss) {\n    var _this = this;\n\n    _classCallCheck(this, ValidationContext);\n\n    this._simpleSchema = ss;\n    this._schema = ss.schema();\n    this._schemaKeys = Object.keys(this._schema);\n    this._validationErrors = []; // Set up validation dependencies\n\n    this._deps = {};\n    var tracker = ss._constructorOptions.tracker;\n\n    if (tracker) {\n      this._depsAny = new tracker.Dependency();\n\n      this._schemaKeys.forEach(function (key) {\n        _this._deps[key] = new tracker.Dependency();\n      });\n    }\n  }\n\n  _createClass(ValidationContext, [{\n    key: '_markKeyChanged',\n    value: function _markKeyChanged(key) {\n      var genericKey = _mongoObject2.default.makeKeyGeneric(key);\n\n      if (this._deps.hasOwnProperty(genericKey)) this._deps[genericKey].changed();\n    }\n  }, {\n    key: '_markKeysChanged',\n    value: function _markKeysChanged(keys) {\n      var _this2 = this;\n\n      if (!keys || !Array.isArray(keys) || !keys.length) return;\n      keys.forEach(function (key) {\n        return _this2._markKeyChanged(key);\n      });\n      this._depsAny && this._depsAny.changed();\n    }\n  }, {\n    key: 'setValidationErrors',\n    value: function setValidationErrors(errors) {\n      var previousValidationErrors = this._validationErrors.map(function (o) {\n        return o.name;\n      });\n\n      var newValidationErrors = errors.map(function (o) {\n        return o.name;\n      });\n      this._validationErrors = errors; // Mark all previous plus all new as changed\n\n      var changedKeys = previousValidationErrors.concat(newValidationErrors);\n\n      this._markKeysChanged(changedKeys);\n    }\n  }, {\n    key: 'addValidationErrors',\n    value: function addValidationErrors(errors) {\n      var _this3 = this;\n\n      var newValidationErrors = errors.map(function (o) {\n        return o.name;\n      });\n      errors.forEach(function (error) {\n        return _this3._validationErrors.push(error);\n      }); // Mark all new as changed\n\n      this._markKeysChanged(newValidationErrors);\n    } // Reset the validationErrors array\n\n  }, {\n    key: 'reset',\n    value: function reset() {\n      this.setValidationErrors([]);\n    }\n  }, {\n    key: 'getErrorForKey',\n    value: function getErrorForKey(key) {\n      var genericKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _mongoObject2.default.makeKeyGeneric(key);\n      var errors = this._validationErrors;\n      return (0, _lodash2.default)(errors, {\n        name: key\n      }) || (0, _lodash2.default)(errors, {\n        name: genericKey\n      });\n    }\n  }, {\n    key: '_keyIsInvalid',\n    value: function _keyIsInvalid(key, genericKey) {\n      return !!this.getErrorForKey(key, genericKey);\n    } // Like the internal one, but with deps\n\n  }, {\n    key: 'keyIsInvalid',\n    value: function keyIsInvalid(key) {\n      var genericKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _mongoObject2.default.makeKeyGeneric(key);\n      if (this._deps.hasOwnProperty(genericKey)) this._deps[genericKey].depend();\n      return this._keyIsInvalid(key, genericKey);\n    }\n  }, {\n    key: 'keyErrorMessage',\n    value: function keyErrorMessage(key) {\n      var genericKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _mongoObject2.default.makeKeyGeneric(key);\n      if (this._deps.hasOwnProperty(genericKey)) this._deps[genericKey].depend();\n      var errorObj = this.getErrorForKey(key, genericKey);\n      if (!errorObj) return '';\n      return this._simpleSchema.messageForError(errorObj);\n    }\n    /**\n     * Validates the object against the simple schema and sets a reactive array of error objects\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(obj) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$extendedCustomCo = _ref.extendedCustomContext,\n          extendedCustomContext = _ref$extendedCustomCo === undefined ? {} : _ref$extendedCustomCo,\n          _ref$ignore = _ref.ignore,\n          ignoreTypes = _ref$ignore === undefined ? [] : _ref$ignore,\n          keysToValidate = _ref.keys,\n          _ref$modifier = _ref.modifier,\n          isModifier = _ref$modifier === undefined ? false : _ref$modifier,\n          mongoObject = _ref.mongoObject,\n          _ref$upsert = _ref.upsert,\n          isUpsert = _ref$upsert === undefined ? false : _ref$upsert;\n\n      var validationErrors = (0, _doValidation2.default)({\n        extendedCustomContext: extendedCustomContext,\n        ignoreTypes: ignoreTypes,\n        isModifier: isModifier,\n        isUpsert: isUpsert,\n        keysToValidate: keysToValidate,\n        mongoObject: mongoObject,\n        obj: obj,\n        schema: this._simpleSchema,\n        validationContext: this\n      });\n\n      if (keysToValidate) {\n        // We have only revalidated the listed keys, so if there\n        // are any other existing errors that are NOT in the keys list,\n        // we should keep these errors.\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          var _loop = function _loop() {\n            var error = _step.value;\n            var wasValidated = keysToValidate.some(function (key) {\n              return key === error.name || error.name.startsWith(key + '.');\n            });\n            if (!wasValidated) validationErrors.push(error);\n          };\n\n          for (var _iterator = this._validationErrors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            _loop();\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      this.setValidationErrors(validationErrors); // Return true if it was valid; otherwise, return false\n\n      return !validationErrors.length;\n    }\n  }, {\n    key: 'isValid',\n    value: function isValid() {\n      this._depsAny && this._depsAny.depend();\n      return this._validationErrors.length === 0;\n    }\n  }, {\n    key: 'validationErrors',\n    value: function validationErrors() {\n      this._depsAny && this._depsAny.depend();\n      return this._validationErrors;\n    }\n  }, {\n    key: 'clean',\n    value: function clean() {\n      var _simpleSchema;\n\n      return (_simpleSchema = this._simpleSchema).clean.apply(_simpleSchema, arguments);\n    }\n  }]);\n\n  return ValidationContext;\n}();\n\nexports.default = ValidationContext;","map":null,"metadata":{},"sourceType":"script"}