{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _clone = require('clone');\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _lodash = require('lodash.includes');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _utility = require('../utility');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction getFieldInfo(mongoObject, key) {\n  var keyInfo = mongoObject.getInfoForKey(key) || {};\n  return {\n    isSet: keyInfo.value !== undefined,\n    value: keyInfo.value,\n    operator: keyInfo.operator || null\n  };\n}\n\nvar AutoValueRunner = function () {\n  function AutoValueRunner(options) {\n    _classCallCheck(this, AutoValueRunner);\n\n    this.options = options;\n    this.doneKeys = [];\n  }\n\n  _createClass(AutoValueRunner, [{\n    key: 'runForPosition',\n    value: function runForPosition(_ref) {\n      var affectedKey = _ref.key,\n          operator = _ref.operator,\n          position = _ref.position,\n          value = _ref.value;\n      var _options = this.options,\n          closestSubschemaFieldName = _options.closestSubschemaFieldName,\n          extendedAutoValueContext = _options.extendedAutoValueContext,\n          func = _options.func,\n          isModifier = _options.isModifier,\n          isUpsert = _options.isUpsert,\n          mongoObject = _options.mongoObject; // If already called for this key, skip it\n\n      if ((0, _lodash2.default)(this.doneKeys, affectedKey)) return;\n      var fieldParentName = (0, _utility.getParentOfKey)(affectedKey, true);\n      var parentFieldInfo = getFieldInfo(mongoObject, fieldParentName.slice(0, -1));\n      var doUnset = false;\n\n      if (Array.isArray(parentFieldInfo.value)) {\n        if (isNaN(affectedKey.split('.').slice(-1).pop())) {\n          // parent is an array, but the key to be set is not an integer (see issue #80)\n          return;\n        }\n      }\n\n      var autoValue = func.call(_extends({\n        closestSubschemaFieldName: closestSubschemaFieldName.length ? closestSubschemaFieldName : null,\n        field: function field(fName) {\n          return getFieldInfo(mongoObject, closestSubschemaFieldName + fName);\n        },\n        isModifier: isModifier,\n        isUpsert: isUpsert,\n        isSet: value !== undefined,\n        key: affectedKey,\n        operator: operator,\n        parentField: function parentField() {\n          return parentFieldInfo;\n        },\n        siblingField: function siblingField(fName) {\n          return getFieldInfo(mongoObject, fieldParentName + fName);\n        },\n        unset: function unset() {\n          doUnset = true;\n        },\n        value: value\n      }, extendedAutoValueContext || {}), mongoObject.getObject()); // Update tracking of which keys we've run autovalue for\n\n      this.doneKeys.push(affectedKey);\n      if (doUnset && position) mongoObject.removeValueForPosition(position);\n      if (autoValue === undefined) return; // If the user's auto value is of the pseudo-modifier format, parse it\n      // into operator and value.\n\n      if (isModifier) {\n        var op = void 0;\n        var newValue = void 0;\n\n        if (autoValue && (typeof autoValue === 'undefined' ? 'undefined' : _typeof(autoValue)) === 'object') {\n          var avOperator = Object.keys(autoValue).find(function (avProp) {\n            return avProp.substring(0, 1) === '$';\n          });\n\n          if (avOperator) {\n            op = avOperator;\n            newValue = autoValue[avOperator];\n          }\n        } // Add $set for updates and upserts if necessary. Keep this\n        // above the \"if (op)\" block below since we might change op\n        // in this line.\n\n\n        if (!op && position.slice(0, 1) !== '$') {\n          op = '$set';\n          newValue = autoValue;\n        }\n\n        if (op) {\n          // Update/change value\n          mongoObject.removeValueForPosition(position);\n          mongoObject.setValueForPosition(op + '[' + affectedKey + ']', (0, _clone2.default)(newValue));\n          return;\n        }\n      } // Update/change value. Cloning is necessary in case it's an object, because\n      // if we later set some keys within it, they'd be set on the original object, too.\n\n\n      mongoObject.setValueForPosition(position, (0, _clone2.default)(autoValue));\n    }\n  }]);\n\n  return AutoValueRunner;\n}();\n\nexports.default = AutoValueRunner;","map":null,"metadata":{},"sourceType":"script"}